  <!DOCTYPE html>
  <html lang="ja">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 - 100%health</title>
    <link rel="stylesheet" href="/1column.css">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="/js/jquery-3.6.0.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/mouse.js"></script>
    <link rel="stylesheet" href="/txt/zakki/tag-style.css">
    <link rel="stylesheet" href="/txt/zakki/zakki-year.css">
    <script>
      $(function () {
        $("#zakkihtml").load("/txt/txt_main.html #zakki-list");
        $("#taghtml").load("/txt/txt_main.html #tag-list");
      });
    </script>
    <script>
      $(document).ready(function () {
        var yearDiv = $('#y2025');
        const year = '2025';

        // 設定値
        const PreviewConfig = {
          maxChars: 400,        // 最大文字数
          minElements: 2,       // 最小要素数（短い記事でも確実に表示）
          maxElements: 8,       // 最大要素数
          textTruncateLength: 150,  // テキスト省略文字数
          maxListItems: 4,      // リスト最大表示項目数
          listItemEstimate: 30, // リスト1項目あたりの推定文字数
          debug: false           // デバッグログの表示
        };

        // 省略処理のメインクラス
        class BalancedArticleProcessor {
          constructor(config) {
            this.config = config;
          }

          log(message, ...args) {
            if (this.config.debug) {
              console.log(`[ArticleProcessor] ${message}`, ...args);
            }
          }

          // 個別要素の処理
          processElement(element) {
            const cloned = element.cloneNode(true);
            let estimatedChars = 0;

            switch (element.tagName) {
              case 'P':
                const text = element.textContent || '';
                if (text.length > this.config.textTruncateLength) {
                  cloned.innerHTML = text.substring(0, this.config.textTruncateLength) + '<span class="ellipsis">...</span>';
                  estimatedChars = this.config.textTruncateLength;
                  this.log(`Truncated paragraph: ${text.length} → ${this.config.textTruncateLength} chars`);
                } else {
                  estimatedChars = text.length;
                  this.log(`Kept full paragraph: ${text.length} chars`);
                }
                break;

              case 'UL':
              case 'OL':
                estimatedChars = this.processListElement(cloned, element);
                break;

              case 'H1':
              case 'H2':
              case 'H3':
              case 'H4':
              case 'H5':
              case 'H6':
                estimatedChars = (element.textContent || '').length;
                this.log(`Processed heading: ${element.tagName} - "${element.textContent}"`);
                break;

              case 'BLOCKQUOTE':
                const quoteText = element.textContent || '';
                if (quoteText.length > this.config.textTruncateLength) {
                  cloned.innerHTML = `<p>${quoteText.substring(0, this.config.textTruncateLength)}<span class="ellipsis">...</span></p>`;
                  estimatedChars = this.config.textTruncateLength;
                } else {
                  estimatedChars = quoteText.length;
                }
                this.log(`Processed blockquote: ${quoteText.length} chars`);
                break;

              default:
                estimatedChars = (element.textContent || '').length;
                this.log(`Processed other element: ${element.tagName}`);
            }

            return { element: cloned, chars: estimatedChars };
          }

          // リスト要素の処理
          processListElement(cloned, original) {
            const items = Array.from(original.children);
            const maxItems = this.config.maxListItems;

            if (items.length > maxItems) {
              // 余分な項目を削除
              Array.from(cloned.children)
                .slice(maxItems)
                .forEach(item => item.remove());

              // 省略表示を追加
              const ellipsis = document.createElement('li');
              const remainingCount = items.length - maxItems;
              ellipsis.innerHTML = `<em>... (他${remainingCount}項目)</em>`;
              ellipsis.style.fontStyle = 'italic';
              ellipsis.style.color = '#666';
              ellipsis.className = 'list-ellipsis';
              cloned.appendChild(ellipsis);

              this.log(`Truncated list: ${items.length} → ${maxItems} items (${remainingCount} hidden)`);

              return Math.min(items.length, maxItems) * this.config.listItemEstimate;
            } else {
              this.log(`Kept full list: ${items.length} items`);
              return items.length * this.config.listItemEstimate;
            }
          }

          // 全ての関連要素を再帰的に取得
          getAllRelevantElements(container) {
            const elements = [];

            function traverse(node) {
              for (const child of node.children) {
                if (['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'UL', 'OL', 'BLOCKQUOTE'].includes(child.tagName)) {
                  elements.push(child);
                } else if (['SECTION', 'DIV', 'ARTICLE'].includes(child.tagName)) {
                  // コンテナ要素の場合は中身を再帰的に処理
                  traverse(child);
                } else {
                  // その他の要素もとりあえず追加
                  elements.push(child);
                }
              }
            }

            traverse(container);
            return elements;
          }

          // メイン処理: バランス型プレビュー作成
          createBalancedPreview(articleBody) {
            const preview = document.createElement('div');
            preview.className = 'article-preview';

            let totalChars = 0;
            let elementCount = 0;

            // 全要素をフラットに取得
            const allElements = this.getAllRelevantElements(articleBody);
            this.log(`Found ${allElements.length} elements to process`);

            for (const element of allElements) {
              // 最小要素数未満なら必ず追加
              if (elementCount < this.config.minElements) {
                const processed = this.processElement(element);
                preview.appendChild(processed.element);
                totalChars += processed.chars;
                elementCount++;
                this.log(`Added element ${elementCount} (minimum guarantee): ${processed.chars} chars, total: ${totalChars}`);
                continue;
              }

              // 最大要素数に達したら停止
              if (elementCount >= this.config.maxElements) {
                this.log(`Reached maximum elements (${this.config.maxElements}), stopping`);
                break;
              }

              // 文字数制限チェック
              const processed = this.processElement(element);
              if (totalChars + processed.chars > this.config.maxChars && elementCount > 0) {
                this.log(`Would exceed character limit (${totalChars + processed.chars} > ${this.config.maxChars}), stopping`);
                break;
              }

              preview.appendChild(processed.element);
              totalChars += processed.chars;
              elementCount++;
              this.log(`Added element ${elementCount}: ${processed.chars} chars, total: ${totalChars}`);
            }

            this.log(`Preview completed: ${elementCount} elements, ${totalChars} chars`);
            return preview;
          }
        }

        // 「続きを読む」リンクの生成
        function createReadMoreLink(articleId, year) {
          const readMoreLink = document.createElement('p');
          readMoreLink.className = 'article-ellipsis';

          // 記事IDから日付を抽出（例：250101 → 2025-01-01）
          const dateStr = articleId.toString();
          const yearPart = dateStr.substring(0, 2);
          const monthPart = dateStr.substring(2, 4);
          const dayPart = dateStr.substring(4, 6);
          const fullDate = `20${yearPart}-${monthPart}-${dayPart}`;

          const link = document.createElement('a');
          link.href = `/txt/zakki/${year}/${monthPart}/days/${fullDate}.html`;
          link.innerHTML = '続きを読む / <span lang="en">read more</span>';
          link.className = 'read-more-link';

          readMoreLink.appendChild(link);

          if (PreviewConfig.debug) {
            console.log('Created read more link for article:', articleId);
          }

          return readMoreLink;
        }

        // フォールバック処理（article-bodyがない場合）
        function createFallbackPreview(articleElement) {
          const textContent = articleElement.textContent;
          const lines = textContent.split('\n').filter(line => line.trim());
          const truncatedText = lines.slice(0, 7).join('\n');

          const preview = document.createElement('div');
          preview.className = 'article-preview';
          preview.innerHTML = `<p>${truncatedText}...</p>`;

          if (PreviewConfig.debug) {
            console.log('Created fallback preview with', lines.length, 'lines');
          }

          return preview;
        }

        // メイン関数：記事を省略して作成
        function createTruncatedArticle(articleElement) {
          const truncatedArticle = document.createElement('article');
          truncatedArticle.id = articleElement.id;
          truncatedArticle.className = articleElement.className;

          // 見出しを保持
          const h3 = articleElement.querySelector('h3');
          if (h3) {
            truncatedArticle.appendChild(h3.cloneNode(true));
          }

          // 記事本文の処理
          const articleBody = articleElement.querySelector('.article-body');
          let preview;

          if (articleBody) {
            // バランス型プロセッサーを使用
            const processor = new BalancedArticleProcessor(PreviewConfig);
            preview = processor.createBalancedPreview(articleBody);

            // 続きを読むリンクを追加
            const readMoreLink = createReadMoreLink(articleElement.id, year);
            preview.appendChild(readMoreLink);

            if (PreviewConfig.debug) {
              console.log(`Article ${articleElement.id}: created balanced preview`);
            }
          } else {
            // フォールバック処理
            preview = createFallbackPreview(articleElement);
          }

          truncatedArticle.appendChild(preview);
          return truncatedArticle;
        }

        // 月別スクリプトを動的にロードする関数
        function loadMonthScript(month) {
          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = `/txt/zakki/${year}/${month}/zakki${month}.js`;
            script.onload = resolve;
            script.onerror = reject;
            document.body.appendChild(script);
          });
        }

        // 12ヶ月分のdiv要素を作成
        for (var i = 1; i <= 12; i++) {
          var monthId = 'm' + ('0' + i).slice(-2);
          var monthDiv = $('<div>').attr('id', monthId);
          yearDiv.append(monthDiv);
        }

        var counter = 1;
        var totalMonths = 12;

        // 月別コンテンツの読み込み
        async function loadMonth(month) {
          var paddedMonth = ('0' + month).slice(-2);
          var monthId = 'm' + paddedMonth;

          try {
            // 1. 月別HTMLの読み込み
            const response = await $.ajax({
              url: `/txt/zakki/${year}/${paddedMonth}/${year}-${paddedMonth}.html`,
              type: 'GET'
            });

            var content = $(response).find('#zakki' + paddedMonth).html();
            if (content) {
              $('#' + monthId).html(content);

              // 2. 月別スクリプトの読み込み
              await loadMonthScript(paddedMonth);

              // 3. 記事読み込み関数の実行
              const funcName = `loadDailyArticles${paddedMonth}`;
              if (typeof window[funcName] === 'function') {
                await window[funcName]();

                // 4. 記事を省略表示に変換
                const articles = document.querySelectorAll(`#${monthId} article`);
                articles.forEach(article => {
                  const truncatedArticle = createTruncatedArticle(article);
                  article.parentNode.replaceChild(truncatedArticle, article);
                });

                if (PreviewConfig.debug) {
                  console.log(`Month ${paddedMonth}: processed ${articles.length} articles`);
                }
              }
            }
          } catch (error) {
            console.error(`Error loading month ${paddedMonth}:`, error);
          }

          // 次の月の処理
          counter++;
          if (counter <= totalMonths) {
            await loadMonth(counter);
          }
        }

        // 1月から読み込み開始
        loadMonth(1);
      });
    </script>

  </head>

  <body>
    <div id="wrapper">
      <header id="header">
        <div id="header-flex">
          <nav id="back" aria-label="戻るナビゲーション">
            <a id="backicon" href="/index.html">
              &lt;
            </a>
          </nav>
          <nav id="address" class="addressbar" aria-label="パンくずナビゲーション">
            <a class="addressbar" href="/index.html">
              100%health
            </a>/
            <a class="addressbar" href="/txt/txt_main.html">
              txt
            </a>/
            <a class="addressbar" href="/txt/zakki/2025/2025.html">
              2025
            </a>
          </nav>
        </div>
      </header>
      <main id="main">
        <br>
        <h1>2025年の雑記帳</h1>

        <div id="y2025">
        </div>
        
      </main>
      <footer id="main-footer">
        <div id="zakkihtml"></div>
        <div id="taghtml"></div>
        <!-- main.jsから#footerへfooter.htmlの挿入 -->
        <div id="footerhtml"></div>
      </footer>
    </div>
    <div id="lightbox">
      <link rel="stylesheet" href="/luminous-basic.min.css">
      <script src="/Luminous.min.js"></script>
      <script>
        new LuminousGallery(document.querySelectorAll('a[href$=jpg],a[href$=png],a[href$=gif],a[href$=webp]'));
      </script>
    </div>
  </body>

  </html>
